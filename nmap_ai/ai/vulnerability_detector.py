"""
AI-powered vulnerability detection module for NMAP-AI.

This module provides intelligent vulnerability detection capabilities by analyzing
nmap scan results and correlating them with vulnerability databases.
"""

import logging
import json
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime
import re
import numpy as np
from dataclasses import dataclass
import requests
import sqlite3
from pathlib import Path

from ..utils.logger import get_logger
from ..utils.helpers import parse_nmap_xml, validate_ip_address
from ..config import Config


logger = get_logger(__name__)


@dataclass
class Vulnerability:
    """Represents a discovered vulnerability."""
    cve_id: str
    severity: str
    score: float
    description: str
    affected_service: str
    port: int
    references: List[str]
    exploit_available: bool
    patch_available: bool
    discovery_method: str


@dataclass
class VulnerabilityReport:
    """Contains vulnerability assessment results."""
    target_ip: str
    scan_time: datetime
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    vulnerabilities: List[Vulnerability]
    risk_score: float
    recommendations: List[str]


class VulnerabilityDetector:
    """
    AI-powered vulnerability detector that analyzes nmap scan results
    and identifies potential security vulnerabilities.
    """

    def __init__(self, config: Optional[Config] = None):
        """
        Initialize the vulnerability detector.
        
        Args:
            config: Configuration object
        """
        self.config = config or Config()
        self.logger = get_logger(__name__)
        self.vuln_db_path = Path(self.config.data_dir) / "vulnerabilities.db"
        self._init_vulnerability_database()
        
        # Common vulnerable service patterns
        self.vulnerable_patterns = {
            'ssh': {
                'versions': ['OpenSSH_7.4', 'OpenSSH_6.6', 'OpenSSH_5.3'],
                'vulnerabilities': ['CVE-2018-15473', 'CVE-2016-6515']
            },
            'http': {
                'versions': ['Apache/2.2', 'nginx/1.10', 'IIS/7.5'],
                'vulnerabilities': ['CVE-2017-15715', 'CVE-2017-7529']
            },
            'ftp': {
                'versions': ['vsftpd 2.3.4', 'ProFTPD 1.3.3c'],
                'vulnerabilities': ['CVE-2011-2523', 'CVE-2010-4221']
            },
            'smtp': {
                'versions': ['Postfix 2.8', 'Sendmail 8.14'],
                'vulnerabilities': ['CVE-2011-1720', 'CVE-2009-4565']
            },
            'smb': {
                'versions': ['Samba 3.0', 'SMBv1'],
                'vulnerabilities': ['CVE-2017-7494', 'MS17-010']
            }
        }
        
        # Severity scoring
        self.severity_weights = {
            'critical': 10.0,
            'high': 7.5,
            'medium': 5.0,
            'low': 2.5
        }

    def _init_vulnerability_database(self):
        """Initialize the local vulnerability database."""
        try:
            self.vuln_db_path.parent.mkdir(parents=True, exist_ok=True)
            
            with sqlite3.connect(self.vuln_db_path) as conn:
                conn.execute('''
                    CREATE TABLE IF NOT EXISTS vulnerabilities (
                        cve_id TEXT PRIMARY KEY,
                        severity TEXT,
                        score REAL,
                        description TEXT,
                        references TEXT,
                        exploit_available BOOLEAN,
                        patch_available BOOLEAN,
                        created_date TEXT
                    )
                ''')
                
                conn.execute('''
                    CREATE TABLE IF NOT EXISTS service_vulnerabilities (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        service_name TEXT,
                        version_pattern TEXT,
                        cve_id TEXT,
                        FOREIGN KEY (cve_id) REFERENCES vulnerabilities (cve_id)
                    )
                ''')
                
                conn.commit()
                
        except Exception as e:
            self.logger.error(f"Failed to initialize vulnerability database: {e}")

    def analyze_scan_results(self, scan_results: Dict[str, Any]) -> VulnerabilityReport:
        """
        Analyze nmap scan results for vulnerabilities.
        
        Args:
            scan_results: Parsed nmap scan results
            
        Returns:
            VulnerabilityReport: Comprehensive vulnerability report
        """
        self.logger.info("Starting vulnerability analysis")
        
        target_ip = scan_results.get('scan', {}).get('target', 'Unknown')
        vulnerabilities = []
        
        # Analyze each host
        for host_ip, host_data in scan_results.get('scan', {}).items():
            if host_ip == 'target':
                continue
                
            host_vulns = self._analyze_host(host_ip, host_data)
            vulnerabilities.extend(host_vulns)
        
        # Generate report
        report = self._generate_report(target_ip, vulnerabilities)
        
        self.logger.info(f"Vulnerability analysis complete. Found {len(vulnerabilities)} vulnerabilities")
        return report

    def _analyze_host(self, host_ip: str, host_data: Dict) -> List[Vulnerability]:
        """Analyze a single host for vulnerabilities."""
        vulnerabilities = []
        
        # Analyze TCP ports
        tcp_ports = host_data.get('tcp', {})
        for port, port_data in tcp_ports.items():
            port_vulns = self._analyze_port(host_ip, int(port), port_data, 'tcp')
            vulnerabilities.extend(port_vulns)
        
        # Analyze UDP ports
        udp_ports = host_data.get('udp', {})
        for port, port_data in udp_ports.items():
            port_vulns = self._analyze_port(host_ip, int(port), port_data, 'udp')
            vulnerabilities.extend(port_vulns)
        
        return vulnerabilities

    def _analyze_port(self, host_ip: str, port: int, port_data: Dict, protocol: str) -> List[Vulnerability]:
        """Analyze a specific port for vulnerabilities."""
        vulnerabilities = []
        
        if port_data.get('state') != 'open':
            return vulnerabilities
        
        service_name = port_data.get('name', '')
        service_product = port_data.get('product', '')
        service_version = port_data.get('version', '')
        
        # Check for known vulnerable services
        service_vulns = self._check_service_vulnerabilities(
            service_name, service_product, service_version, port
        )
        vulnerabilities.extend(service_vulns)
        
        # Check for default credentials
        default_cred_vulns = self._check_default_credentials(service_name, port)
        vulnerabilities.extend(default_cred_vulns)
        
        # Check for insecure configurations
        config_vulns = self._check_insecure_configurations(service_name, port_data, port)
        vulnerabilities.extend(config_vulns)
        
        return vulnerabilities

    def _check_service_vulnerabilities(self, service: str, product: str, version: str, port: int) -> List[Vulnerability]:
        """Check for known vulnerabilities in specific service versions."""
        vulnerabilities = []
        
        # Normalize service name
        service_key = service.lower()
        if service_key in ['http', 'https', 'http-proxy']:
            service_key = 'http'
        elif service_key in ['ssh']:
            service_key = 'ssh'
        elif service_key in ['ftp', 'ftps']:
            service_key = 'ftp'
        elif service_key in ['smtp', 'smtps']:
            service_key = 'smtp'
        elif service_key in ['microsoft-ds', 'netbios-ssn']:
            service_key = 'smb'
        
        if service_key not in self.vulnerable_patterns:
            return vulnerabilities
        
        patterns = self.vulnerable_patterns[service_key]
        
        # Check version patterns
        full_version = f"{product} {version}".strip()
        for vuln_version in patterns['versions']:
            if vuln_version.lower() in full_version.lower():
                # Create vulnerability entries
                for cve_id in patterns['vulnerabilities']:
                    vuln = Vulnerability(
                        cve_id=cve_id,
                        severity='high',
                        score=7.5,
                        description=f"Vulnerable {service} service detected: {full_version}",
                        affected_service=service,
                        port=port,
                        references=[f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"],
                        exploit_available=True,
                        patch_available=True,
                        discovery_method='version_detection'
                    )
                    vulnerabilities.append(vuln)
        
        return vulnerabilities

    def _check_default_credentials(self, service: str, port: int) -> List[Vulnerability]:
        """Check for services that commonly use default credentials."""
        vulnerabilities = []
        
        default_cred_services = {
            'ftp': ['admin:admin', 'anonymous:anonymous'],
            'ssh': ['root:root', 'admin:admin'],
            'telnet': ['admin:admin', 'root:root'],
            'http': ['admin:admin', 'admin:password'],
            'https': ['admin:admin', 'admin:password'],
            'snmp': ['public', 'private'],
            'mysql': ['root:', 'root:root'],
            'mssql': ['sa:', 'sa:sa']
        }
        
        service_key = service.lower()
        if service_key in default_cred_services:
            vuln = Vulnerability(
                cve_id='CWE-521',
                severity='high',
                score=7.0,
                description=f"Service {service} on port {port} may be using default credentials",
                affected_service=service,
                port=port,
                references=['https://cwe.mitre.org/data/definitions/521.html'],
                exploit_available=True,
                patch_available=True,
                discovery_method='default_credentials_check'
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities

    def _check_insecure_configurations(self, service: str, port_data: Dict, port: int) -> List[Vulnerability]:
        """Check for insecure service configurations."""
        vulnerabilities = []
        
        # Check for unencrypted services
        insecure_services = {
            'ftp': 'FTP transmits credentials in plaintext',
            'telnet': 'Telnet transmits all data in plaintext',
            'http': 'HTTP transmits data in plaintext',
            'smtp': 'SMTP may transmit credentials in plaintext',
            'pop3': 'POP3 may transmit credentials in plaintext',
            'imap': 'IMAP may transmit credentials in plaintext'
        }
        
        service_key = service.lower()
        if service_key in insecure_services:
            vuln = Vulnerability(
                cve_id='CWE-319',
                severity='medium',
                score=5.0,
                description=insecure_services[service_key],
                affected_service=service,
                port=port,
                references=['https://cwe.mitre.org/data/definitions/319.html'],
                exploit_available=False,
                patch_available=True,
                discovery_method='configuration_analysis'
            )
            vulnerabilities.append(vuln)
        
        # Check for anonymous access
        if 'anonymous' in str(port_data).lower():
            vuln = Vulnerability(
                cve_id='CWE-284',
                severity='medium',
                score=5.5,
                description=f"Anonymous access detected on {service} port {port}",
                affected_service=service,
                port=port,
                references=['https://cwe.mitre.org/data/definitions/284.html'],
                exploit_available=True,
                patch_available=True,
                discovery_method='anonymous_access_check'
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities

    def _generate_report(self, target_ip: str, vulnerabilities: List[Vulnerability]) -> VulnerabilityReport:
        """Generate a comprehensive vulnerability report."""
        # Count vulnerabilities by severity
        severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        total_score = 0.0
        
        for vuln in vulnerabilities:
            severity_counts[vuln.severity] += 1
            total_score += vuln.score
        
        # Calculate risk score
        risk_score = min(total_score / len(vulnerabilities) if vulnerabilities else 0.0, 10.0)
        
        # Generate recommendations
        recommendations = self._generate_recommendations(vulnerabilities, severity_counts)
        
        return VulnerabilityReport(
            target_ip=target_ip,
            scan_time=datetime.now(),
            total_vulnerabilities=len(vulnerabilities),
            critical_count=severity_counts['critical'],
            high_count=severity_counts['high'],
            medium_count=severity_counts['medium'],
            low_count=severity_counts['low'],
            vulnerabilities=vulnerabilities,
            risk_score=risk_score,
            recommendations=recommendations
        )

    def _generate_recommendations(self, vulnerabilities: List[Vulnerability], severity_counts: Dict) -> List[str]:
        """Generate security recommendations based on found vulnerabilities."""
        recommendations = []
        
        if severity_counts['critical'] > 0:
            recommendations.append("❌ CRITICAL: Address critical vulnerabilities immediately")
        
        if severity_counts['high'] > 0:
            recommendations.append("🔴 HIGH: Prioritize patching high-severity vulnerabilities")
        
        # Service-specific recommendations
        services = set(vuln.affected_service for vuln in vulnerabilities)
        
        if 'ftp' in services:
            recommendations.append("🔒 Consider using SFTP instead of FTP for secure file transfer")
        
        if 'telnet' in services:
            recommendations.append("🔒 Replace Telnet with SSH for secure remote access")
        
        if 'http' in services:
            recommendations.append("🔒 Implement HTTPS for all web services")
        
        if any('default' in vuln.discovery_method for vuln in vulnerabilities):
            recommendations.append("🔑 Change all default credentials immediately")
        
        # General recommendations
        recommendations.extend([
            "🛡️ Keep all software and services updated",
            "🔥 Configure firewalls to restrict unnecessary access",
            "📊 Regular vulnerability scanning is recommended",
            "🎯 Implement network segmentation where possible"
        ])
        
        return recommendations

    def export_report(self, report: VulnerabilityReport, format_type: str = 'json') -> str:
        """
        Export vulnerability report in specified format.
        
        Args:
            report: VulnerabilityReport to export
            format_type: Export format ('json', 'html', 'csv')
            
        Returns:
            str: Formatted report content
        """
        if format_type.lower() == 'json':
            return self._export_json(report)
        elif format_type.lower() == 'html':
            return self._export_html(report)
        elif format_type.lower() == 'csv':
            return self._export_csv(report)
        else:
            raise ValueError(f"Unsupported format: {format_type}")

    def _export_json(self, report: VulnerabilityReport) -> str:
        """Export report as JSON."""
        def serialize_vulnerability(vuln):
            return {
                'cve_id': vuln.cve_id,
                'severity': vuln.severity,
                'score': vuln.score,
                'description': vuln.description,
                'affected_service': vuln.affected_service,
                'port': vuln.port,
                'references': vuln.references,
                'exploit_available': vuln.exploit_available,
                'patch_available': vuln.patch_available,
                'discovery_method': vuln.discovery_method
            }
        
        report_dict = {
            'target_ip': report.target_ip,
            'scan_time': report.scan_time.isoformat(),
            'summary': {
                'total_vulnerabilities': report.total_vulnerabilities,
                'critical_count': report.critical_count,
                'high_count': report.high_count,
                'medium_count': report.medium_count,
                'low_count': report.low_count,
                'risk_score': report.risk_score
            },
            'vulnerabilities': [serialize_vulnerability(v) for v in report.vulnerabilities],
            'recommendations': report.recommendations
        }
        
        return json.dumps(report_dict, indent=2)

    def _export_html(self, report: VulnerabilityReport) -> str:
        """Export report as HTML."""
        severity_colors = {
            'critical': '#DC3545',
            'high': '#FD7E14', 
            'medium': '#FFC107',
            'low': '#28A745'
        }
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Vulnerability Report - {report.target_ip}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #f8f9fa; padding: 20px; border-radius: 5px; }}
                .summary {{ display: flex; justify-content: space-around; margin: 20px 0; }}
                .severity-box {{ text-align: center; padding: 10px; border-radius: 5px; color: white; }}
                .vuln-item {{ margin: 10px 0; padding: 15px; border-left: 4px solid #ddd; }}
                .recommendations {{ background: #e9ecef; padding: 15px; border-radius: 5px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Vulnerability Assessment Report</h1>
                <p><strong>Target:</strong> {report.target_ip}</p>
                <p><strong>Scan Time:</strong> {report.scan_time.strftime('%Y-%m-%d %H:%M:%S')}</p>
                <p><strong>Risk Score:</strong> {report.risk_score:.1f}/10</p>
            </div>
            
            <div class="summary">
                <div class="severity-box" style="background-color: {severity_colors['critical']}">
                    <h3>{report.critical_count}</h3>
                    <p>Critical</p>
                </div>
                <div class="severity-box" style="background-color: {severity_colors['high']}">
                    <h3>{report.high_count}</h3>
                    <p>High</p>
                </div>
                <div class="severity-box" style="background-color: {severity_colors['medium']}">
                    <h3>{report.medium_count}</h3>
                    <p>Medium</p>
                </div>
                <div class="severity-box" style="background-color: {severity_colors['low']}">
                    <h3>{report.low_count}</h3>
                    <p>Low</p>
                </div>
            </div>
            
            <h2>Vulnerabilities</h2>
        """
        
        for vuln in report.vulnerabilities:
            color = severity_colors.get(vuln.severity, '#6c757d')
            html += f"""
            <div class="vuln-item" style="border-left-color: {color}">
                <h4>{vuln.cve_id} - {vuln.affected_service}:{vuln.port}</h4>
                <p><strong>Severity:</strong> <span style="color: {color}">{vuln.severity.upper()}</span> 
                   (Score: {vuln.score})</p>
                <p><strong>Description:</strong> {vuln.description}</p>
                <p><strong>Exploit Available:</strong> {'Yes' if vuln.exploit_available else 'No'}</p>
                <p><strong>Patch Available:</strong> {'Yes' if vuln.patch_available else 'No'}</p>
            </div>
            """
        
        html += f"""
            <h2>Recommendations</h2>
            <div class="recommendations">
                <ul>
                    {''.join(f'<li>{rec}</li>' for rec in report.recommendations)}
                </ul>
            </div>
        </body>
        </html>
        """
        
        return html

    def _export_csv(self, report: VulnerabilityReport) -> str:
        """Export report as CSV."""
        import csv
        import io
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow([
            'CVE ID', 'Severity', 'Score', 'Service', 'Port',
            'Description', 'Exploit Available', 'Patch Available'
        ])
        
        # Write vulnerabilities
        for vuln in report.vulnerabilities:
            writer.writerow([
                vuln.cve_id,
                vuln.severity,
                vuln.score,
                vuln.affected_service,
                vuln.port,
                vuln.description,
                vuln.exploit_available,
                vuln.patch_available
            ])
        
        return output.getvalue()
